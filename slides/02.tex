% Written in 2015 by Manuel Pégourié-Gonnard
% SPDX-License-Identifier: CC-BY-SA-4.0

\documentclass{mpg-ep-slides}

\author[MPG]{Manuel Pégourié-Gonnard\\
  \href{mailto:mpg@elzevir.fr}{{mpg@elzevir.fr}}
}
\institute[ARM]{\normalsize ARM France - IoT - mbed TLS}
\license{%
  \url{https://github.com/mpg/cours-tls} \\[.5ex]
  \href{https://creativecommons.org/licenses/by-sa/4.0/}{CC-BY-SA 4.0}
}

\title{Cours de cryptologie appliquée de l'EPITA \\ TLS - partie 2}
\date{23 novembre 2015}

\DeclareMathOperator\RSA{RSA}
\DeclareMathOperator\RSAPKCS{RSA\_PKCS1\_15}
\DeclareMathOperator\PKCS{PKCS1\_15}

\begin{document}

\lictitle

\section[Handshake]{Poignée de mains : généralités}
\tocsect

\begin{frame}{Rappel}
  % cf frame "Les couches de TLS" partie 1
  \begin{center}
    \renewcommand\arraystretch{1.5}
    \begin{tabular}{|c|c|c|c|}
      \hline
      Handshake & ChangeCipherSpec & Alert &
      \multicolumn{1}{|c|}{ \color{gray} HTTP, SMTP, etc. } \\ \hline
      \multicolumn{4}{|c|}{Record} \\ \hline
      \multicolumn{4}{|c|}{\color{gray} TCP, UDP} \\ \hline
    \end{tabular}
  \end{center}

  \begin{block}{Handshake}
    \begin{itemize}
      \item Négociation \emph{fiable} des paramètres
      \item Établissement de clé de session \emph{secrètes}
      \item \emph{Authentification} du serveur, voire du client
      \item Crypto (en général) asymétrique + symétrique
    \end{itemize}
  \end{block}
  \begin{block}{Record}
    \begin{itemize}
      \item \emph{Confidentialité} et \emph{intégrité} des données
      \item Crypto symétrique uniquement
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[containsverbatim]{Flot général}
  \begin{Verbatim}[gobble=4, fontsize=\small]
    ClientHello          -------->
                                            ServerHello
                                           Certificate*
                                     ServerKeyExchange*
                                    CertificateRequest*
                         <--------      ServerHelloDone
    Certificate*
    ClientKeyExchange
    CertificateVerify*
    [ChangeCipherSpec]
    Finished#            -------->
                                     [ChangeCipherSpec]
                         <--------            Finished#
    Application Data#    <------->    Application Data#
  \end{Verbatim}
  \texttt{*} = optionel, \texttt{\#} = chiffré
\end{frame}

\begin{frame}[containsverbatim]{Encodage des messages}
  \begin{center}
    \renewcommand\arraystretch{1.2}
    \begin{tabular}{|c|c|c|c|p{8em}|}
      \hline
      T & L1 & L2 & L3 & \centering \emph{(contenu)} \cr
      \hline
    \end{tabular}
  \end{center}

  \begin{Verbatim}[gobble=4, fontsize=\footnotesize]
    struct {
        HandshakeType msg_type;    /* handshake type */
        uint24 length;             /* bytes in message */
        select (HandshakeType) {
            case client_hello:        ClientHello;
            case server_hello:        ServerHello;
            [...]
        } body;
    } Handshake;

    enum {
        client_hello(1), server_hello(2), [...]
        finished(20), (255)
    } HandshakeType;
  \end{Verbatim}
\end{frame}

\begin{frame}[containsverbatim]{ClientHello}
  \begin{Verbatim}[gobble=4, fontsize=\scriptsize]
    struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suites<2..2^16-2>;
        CompressionMethod compression_methods<1..2^8-1>;
        select (extensions_present) {
            case false:
                struct {};
            case true:
                Extension extensions<0..2^16-1>;
        };
    } ClientHello;

    struct {
        uint32 gmt_unix_time;
        opaque random_bytes[28];
    } Random;
    opaque SessionID<0..32>;
    uint8 CipherSuite[2];
    enum { null(0), (255) } CompressionMethod;
  \end{Verbatim}
\end{frame}

\begin{frame}[containsverbatim]{ServerHello}
  \begin{Verbatim}[gobble=4, fontsize=\scriptsize]
    struct {
        ProtocolVersion server_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suite;
        CompressionMethod compression_method;
        select (extensions_present) {
            case false:
                struct {};
            case true:
                Extension extensions<0..2^16-1>;
        };
    } ServerHello;

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;
    enum {
        signature_algorithms(13), (65535)
    } ExtensionType;
  \end{Verbatim}
\end{frame}

\begin{frame}{Remarques sur les Hello}
  \begin{block}{Négociation}
    \begin{itemize}
      \item Le client propose, le serveur dispose
      \item Le serveur DOIT ignorer silencieusement les valeurs inconnues
        (version, suites, compression, extensions)
    \end{itemize}
  \end{block}

  \begin{block}{Suites}
    \begin{itemize}
      \item TLS_\emph{KEYEX}_WITH_\emph{CIPHER}_\emph{HASH}
      \item Ex recommandé : TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      \item OpenSSL a des noms différents, ex AES128-SHA
      \item Plus de 300 définies, seulement une poignée recommandée
      \item \url{https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml\#tls-parameters-4}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[containsverbatim]{Dérivation des clés}
  \begin{itemize}
    \item L'échange de clé fourni un secret pré-maître (PMS) de longueur
      variable
    \item On en dérive un secret maître (MS) de 48 octets :
      \begin{Verbatim}[gobble=8]
        MS = PRF(PMS, "master secret",
                 ClientHello.random + ServerHello.random)
                 [0..47];
      \end{Verbatim}
    \item La fonction pseudo-aléatoire (PRF) est basée sur des hash (MD5+SHA1,
      SHA-256) et est utilisée comme KDF
    \item Un bloc de clés est dérivé du MS en appliquant la PRF
    \item Il est découpé en clés et IV (client/serveur,
      AES/HMAC)
    \item RFC 7627 et TLS 1.3 remplacent les random par \emph{session hash}
      (hash de toute la poignée de main) (cf \emph{triple handshake})
  \end{itemize}
\end{frame}

\begin{frame}[containsverbatim]{Le message Finished}
  \begin{Verbatim}[gobble=4, fontsize=\footnotesize]
    struct {
        opaque verify_data[verify_data_length];
    } Finished;

    verify_data
       PRF(master_secret, finished_label, Hash(handshake_messages))
          [0..verify_data_length-1];
  \end{Verbatim}

  \begin{itemize}
    \item En pratique \texttt{verify_data_length} est 12 octets
    \item Le but est d'assurer la fiabilité de la négociation : un attaquant
      qui essaie d'influencer la négociation sera détecté
    \item Sert aussi de confirmation de clé, ce qui simplifie les preuves de
      sécurité
  \end{itemize}
\end{frame}

\begin{frame}{Serveur intolérants et attaque en downgrade}
  \begin{itemize}
    \item Des serveurs codés avec les pieds rejettent les ClientHello avec
      une version « trop » élevée, ou avec des extensions
    \item Certaines middlebox font de même
    \item Les clients qui veulent quand même communiquer dans ce cas font un
      \emph{fallback} avec un ClientHello.version plus faible
    \item Ce fallback hors-protocole n'est pas protégé par le Finished
    \item Un serveur intolérant est indistiguable d'un attaquant
    \item Ce fallback n'est donc \emph{pas sûr} (ex. partie DLE de POODLE)
    \item On a un compromis utilisabilité-sécurité (pour changer !)
    \item Le RFC 7507 améliore la situation avec une \emph{signaling
        ciphersuite value} (SCSV) indiquant le fallback
  \end{itemize}
\end{frame}

\section[RSA]{Transport de clé RSA}
\tocsect

\begin{frame}[containsverbatim]{Principe}
  \begin{Verbatim}[gobble=4, fontsize=\small]
    ClientHello          -------->
                                            ServerHello
                                            Certificate
                         <--------      ServerHelloDone
    ClientKeyExchange
    [ChangeCipherSpec] ...

      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;
      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;
      struct {
          EncryptedPreMasterSecret;
      } ClientKeyExchange;
  \end{Verbatim}
\end{frame}

\begin{frame}{L'attaque de Bleichenbacher (1)}
  \begin{block}{Oracle de padding sur PKCS\#1 v1.5}
    \begin{itemize}
      \item Rappel : $\RSAPKCS(m) =
        \RSA(\PKCS(m))$
      \item \(
          \PKCS(m) =
          \begin{array}{|c|c|c|c|c|} \hline
            \texttt{00} & \texttt{02} & \text{pad} & \texttt{00} & m \\ \hline
          \end{array}
        \)
      \item Autrefois, les serveurs envoyaient une erreur spécifique si le
        padding était incorrect
      \item L'attaquant envoie un chiffré $c'$ arbitraire, observe la réponse
      \item Si pas d'erreur de padding (une fois sur environ $2^{16}$), alors
        $m' = \RSA^{-1}(c')$ commence par \texttt{00 02}.
      \item Autrement dit, dans ce cas,
        $2 \cdot 2^{l-16} \le m' < 3 \cdot 2^{l-16}$
        où $l$ est la longueur en bits de la clé.
    \end{itemize}
  \end{block}

  \begin{block}{Propriété algébrique de RSA}
    RSA est un homomorphisme : $\RSA(m_1 m_2) = \RSA(m_1) \RSA(m_2)$
  \end{block}
\end{frame}

\begin{frame}{L'attaque de Bleichenbacher (2)}
  \begin{block}{Principe de l'attaque}
    \begin{itemize}
      \item On connaît $c$ et on va trouver $m$ en consultant l'oracle
      \item On pose $B = 2^{l-16}$, on sait déjà que $m \in [2B, 3B-1]$
      \item On cherche $s_1$ tel que $c \cdot s_1^e$ soit
        accepté par l'oracle ; on a
        \begin{align}
          m \cdot s_1 \mod n
          & \in [2B, 3B-1]
          \\ m \cdot s_1
          & \in \cup_{r \in \mathbb N} [2B + rn, 3B-1 + rn]
          \\ m
          & \in \cup_{r \in \mathbb N}
          \left[ \frac{2B + rn}{s_1}, \frac{3B-1 + rn}{s_1} \right]
          \cap [2B, 3B-1]
        \end{align}
      \item On itère (voir gribouillis au tableau)
      \item Au total quelques millions de requêtes suffisent : faisable
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{L'attaque de Bleichenbacher (3)}
  \begin{block}{Comment traiter EncryptedPreMasterSecret}
    \begin{itemize}
      \item Naïf : \only<2->{\st}{si mauvais padding, erreur} ;
        \only<3->{\st}{si mauvaise version, erreur}
      \item<2-> Attaque de Bleichenbacher (1998) : oracle de padding
      \item<2-> TLS 1.0 : Si mauvais padding, on génère un PMS aléatoire,
        erreur reportée au Finished ; (\only<3->{\st}{si mauvaise version
          erreur})
      \item<3-> Attaque de Klima (2003) : oracle de version
      \item<3-> TLS 1.1 : \only<4->{\st}{Si mauvais padding, on génère un
          PMS aléatoire et on l'utilise} ; si mauvaise version pareil
      \item<4-> TLS 1.2 : On génère un PMS aléatoire ; si mauvais padding ou
        mauvaise version, ou l'utilise
      \item<4-> Usenix 2014 : new Bleichenbacher side channels
      \item<4-> Voir \texttt{ssl\_parse\_encrypted\_pms()} dans mbed TLS
      \item<5-> La « vraie » solution serait d'utiliser OAEP
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Concept de (Perfect) Forward Secrecy}
  \begin{block}{Problème avec le transport de clé RSA}
    \begin{itemize}
      \item Un attaquant enregistre plein de communications
      \item Plus tard, il obtient la clé RSA du serveur (faille sur le
        serveur, national security letter, factorisation, \dots)
      \item Il peut alors déchiffer toutes les communications enregistrées
    \end{itemize}
  \end{block}

  \begin{block}{Forward Secrecy}
    \begin{itemize}
      \item C'est quand l'attaque précédente n'est pas possible
        \texttt{\string:-)}
      \item Offerte par les suites basées sur Diffie-Hellman
    \end{itemize}
  \end{block}
\end{frame}

\section[(EC)DHE]{Échange de clé Diffie-Hellman (elliptique)}
\tocsect

% rappel RSA/DL et ECC
% principe DHE-RSA, ECDHE-RSA, ECDHE-ECDSA
% pb taille de paramètre FFDH - Logjam 1

\section[Timing]{Attaques par timing sur RSA et ECDSA}
\tocsect

% principe square-and-multiply, papier practical
% square-and-always-multipy, still practical
% aparté : ECDSA PS3, deterministic ECDSA
% caching, branch prediction, securecoding

\section[PKIX]{Infrastructure à clé publique X.509}
\tocsect

% principe chaine, racine de confiance
% la honte : validation de la chaine, validation du nom
% récovation : CRL, OCSP, CRLsets
% incidents Comodo, ANSSI, Symantec, etc TBTF
% principe CT
% HPKP
% DANE

\section[Échanges]{Autres échanges de clé}
\tocsect

% *-PSK
% DH_anon, DSA, etc?
% export : FREAK, Logjam 2

\section[Attaques]{Autres attaques}
\tocsect

% stripping (HTTP, STARTTLS) - HSTS
% Renego (extension) - 3HS (session hash)
% Impl: debian/OpenSSL, heartbleed, CCS, goto fail
% Impl 2: memset(0) X.509
% DoS (DTLS - DDoS amplification)

\section{Conclusion}
\tocsect

% rappel : primitives OK et cassées, tailles de clé
% compromis : sécurité vs interop, perf/cout, admin, etc
% aperçu TLS 1.3

\end{document}
