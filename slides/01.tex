\documentclass{mpg-ep-slides}

\author[MPG]{Manuel Pégourié-Gonnard}
\institute[ARM]{\normalsize ARM France - IoT - mbed TLS}
\title{Cours de cryptologie appliquée de l'EPITA \\ TLS - partie 1}
\date{19 novembre 2015}

\begin{document}

\maketitle

\section{Introduction}
\tocsect

\begin{frame}{TLS ça fait quoi ?}
  Ça assure la sécurité des \emph{communications} :
  \begin{description}
    \item[Confidentialité] Un attaquant qui peut tout écouter ne peut rien
      apprendre sur les données échangées, à part peut-être leur longueur.
    \item[Intégrité] Un attaquant qui modifie les données en transit sera
      détecté.
    \item[Authentification] optionnelle d'une ou des deux parties :
      l'attaquant ne peut pas se faire passer pour quelqu'un d'autre.
  \end{description}
\end{frame}

\begin{frame}{Quelles menaces ?}
  RFC 3553 section 3 : the Internet threat model (2003)

  \begin{columns}
    \column[t]{.5\textwidth}
    \begin{block}{Attaquant réseau passif}
      \begin{itemize}
        \item Ne fait qu'écouter
        \item Attaque la confidentialité
        \item<2-> Échelle (perpass)
        \item<3-> Attaques « du futur »
      \end{itemize}
    \end{block}

    \begin{block}{Tout le reste}<4->
      Man-in-the-Browser, bugs, sécurité du poste local, utilisateurs, etc.
    \end{block}

    \column[t]{.5\textwidth}
    \begin{block}{Attaquant réseau actif}
      \begin{itemize}
        \item Peut modifier les messages
        \item Attaque l'authenticité, l'intégrité, la confidentialité
        \item Man-in-the-middle (MitM)
        \item<2-> Plus coûteux (ciblé ?)
      \end{itemize}
    \end{block}

    \begin{block}{Canaux auxiliaires}<4->
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}{Ça s'utilise où ?}
  \begin{block}{Couche}
    \begin{description}
      \item[Application] HTTP, IMAP, SMTP, XMPP, \visible<2->{RTSP}
      \item[Session] TLS, \visible<2->{DTLS}
      \item[Transport] TCP, \visible<2->{UDP}
      \item[Internet] IPv4, IPv6
      \item[Lien] tout ce que vous voulez
    \end{description}
  \end{block}

  \begin{block}{Modes}
    \begin{itemize}
      \item avec port dédié : HTTP/80 \textrightarrow{} HTTPS/443
      \item sur le même port : STARTTLS (IMAP, SMTP, XMPP)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Versions}
  \begin{center}
    \begin{tabular}{rcccl}
      \toprule
      Nom & année & RFC & die-die-die & « vraie » version \\
      \midrule
      SSL 1.0 & -- & -- & mort-né & 1.0 \\
      SSL 2.0 & 1995 & -- & 6176 (2011) & 2.0 \\
      SSL 3.0 & 1996 & 6101 & 7568 (2015) & 3.0 \\
      TLS 1.0 & 1999 & 2246 & -- & 3.1 \\
      TLS 1.1 & 2006 & 4346 & -- & 3.2 \\
      DTLS 1.0 & 2006 & 4347 & -- & 3.2 \\
      TLS 1.2 & 2008 & 5246 & -- & 3.3 \\
      DTLS 1.2 & 2012 & 6347 & -- & 3.3 \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{La réalité}
  En vrai, il faut lire un peu plus de RFC\dots

  \begin{description}
    \item[Sécurité] 5746 secure renegotiation, 7627 session hash, 7366
      encrypt-then-mac, 7507 downgrade SCSV,
    \item[Algos] (300+ suites définies !) : 4279 PSK, 4492 ECC, 5054 SRP, 5288
      AES-GCM, 5289 ECC-AES-GCM, 5487 PSK-AES-GCM, 5489 ECDHE-PSK, 6655
      AES-CCM, 7251 ECC-AES-CCM, \dots
    \item[Fonctionnalités] 6066 extensions diverses, 5878 autorisation, 6520
      heartbeat, 5077 tickets de session, 7250 raw public key, 6091 OpenPGP,
      7301 ALPN, \dots
    \item[Usage] 7457 attaques, 7525 bonnes pratiques générales, 7590 XMPP,
      d'autres à venir
  \end{description}

  Cf les registres sur iana.org.
\end{frame}

\begin{frame}{Plus de réalité}
  En 2015, sur les sites les plus populaires accessibles en HTTPS
  \begin{itemize}
    \item environ un tiers considérés sûrs ;
    \item 14~\% acceptent des algos peu sûrs ;
    \item 31~\% acceptent SSL 3.0 ;
    \item 69~\% offrent TLS 1.2 ;
    \item 75~\% offrent la \emph{forward secrecy} ;
    \item 99,9~\% ont un certificat avec un clé assez grande.
  \end{itemize}

  Source : \url{https://www.trustworthyinternet.org/ssl-pulse/}

  \medskip

  Sur le million de sites les plus populaires, en 2014, seuls 45~\%
  accessible en HTTPS\dots
\end{frame}


\section[Couche record]{La couche record}
\tocsect

\begin{frame}{Les couches de TLS}
  \begin{center}
    \renewcommand\arraystretch{1.5}
    \begin{tabular}{|c|c|c|c|}
      \hline
      Handshake & ChangeCipherSpec & Alert &
      \multicolumn{1}{|c|}{ \color{gray} HTTP, SMTP, etc. } \\ \hline
      \multicolumn{4}{|c|}{Record} \\ \hline
      \multicolumn{4}{|c|}{\color{gray} TCP, UDP} \\ \hline
    \end{tabular}
  \end{center}

  \begin{itemize}
    \item Handshake et ChangeCipherSpec (CCS) pour établir la connection
    \item Alert rarement : problèmes, fin de connection
    \item Record pour tout : encapsule, chiffre et authentifie les messages
  \end{itemize}
\end{frame}

\begin{frame}{Structure globale}
  \begin{description}
    \item[Type] un octet : CCS = 20, Alert = 21, HS = 22, App = 23
    \item[Version] deux octets : 0x03 0x03 pour TLS 1.2
    \item[Length] deux octets : longueur du reste en gros-boutiste (limitée à
      $2^{14}$ octets, soit 16 Ko).
  \end{description}

  \begin{center}
    \renewcommand\arraystretch{1.2}
    \begin{tabular}{|c|c|c|c|c|p{5em}|}
      \hline
      T & VM & Vm & L1 & L2 & \centering ... \cr
      \hline
    \end{tabular}
  \end{center}

  Trois types de chiffrement-authentification :
  \begin{enumerate}
    \item Par flot (y compris NULL)
    \item Par bloc avec CBC
    \item AEAD = authenticated encryption with additional data (seulement TLS
      1.2)
  \end{enumerate}
\end{frame}

\begin{frame}{Compression (1)}
  La couche \emph{record} peut compresser avant de chiffrer. Ceci n'est
  \emph{plus} recommandé.

  \begin{block}{L'attaque CRIME}
    \begin{itemize}
      \item Compression Ratio Info-leak Made Easy
      \item Idée de 2002, exploit (public) en 2012
      \item Application possible : fuite de cookies sécurisé
        \begin{enumerate}
          \item On connait \texttt{Cookie secret=}
          \item Pour chaque x, on ajoute \texttt{Cookie secret=x} et on mesure
            la longueur du chiffré
          \item La valeur qui donne un résultat plus court est la bonne
          \item On itère pour les caractères suivants
        \end{enumerate}
      \item Vole un cookie en 30 secondes
    \end{itemize}
  \end{block}

  Dans TLS 1.3, la compression ne sera plus disponible.
\end{frame}

\begin{frame}{Compression (2)}
  \begin{block}{Conditions pour CRIME}
    \begin{enumerate}
      \item L'attaquant peut injecter du texte clair (JS, actif)
      \item L'attaquant peut observer le chiffré (réseau, passif)
      \item La compresssion TLS doit être activée
    \end{enumerate}
  \end{block}

  \begin{block}{Variantes}
    \begin{description}
      \item[TIME] Timing Info-leak Make Easy : supprime la condition 2, mesure
        le temps à la place
      \item[BREACH] Browser Reconnaissance \& Exfiltration via Adaptive
        Compression of Hypertext : exploite la compression HTTP, plus
        répandue.
    \end{description}
  \end{block}
\end{frame}

\begin{frame}{Chiffrement par flot (RC4)}
  \begin{block}{Chiffrement authentifié}
    \begin{itemize}
      \item MAC = HMAC(type, version, longueur, message)
      \item Chiffré = RC4(message, MAC)
      \item Envoyé = Chiffré
      \item L'état RC4 est conservé entre les messages (problème pour DTLS)
    \end{itemize}
  \end{block}

  \begin{block}{Problème : RC4 n'est plus sûr}
    \begin{itemize}
      \item 2013 : RC4 utilisé pour plus de 60~\% des connections HTTPS
      \item 2013 : Royal Holloway, presque pratique ($2^{24}$ chiffrés)
      \item début 2015 : RFC 7465 MUST NOT RC4
      \item mi 2015 : Bar-mitzvah, NOMORE, utilisable en pratique
      \item courant 2015 : RC4 retiré des navigateurs courants
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[containsverbatim]{Apparté : comment vérifier un MAC}
  \begin{block}{Méthode naturelle}
    \begin{enumerate}
      \item Calculer la bonne valeur
      \item Comparer avec la valeur reçue avec \texttt{memcmp()}
    \end{enumerate}
  \end{block}

  \begin{block}{Attaque par timing}
    \begin{itemize}
      \item La durée d'exécution de \texttt{memcmp()} est proportionnelle à la
        longueur du préfixe correct
      \item On brute-force octet par octet
    \end{itemize}
  \end{block}

  \begin{block}{Une solution}
    \begin{Verbatim}[gobble=4]
      unsigned char diff = 0;
      for (size_t i = 0; i < len; i++)
          diff |= a[i] ^ b[i];
    \end{Verbatim}
  \end{block}
\end{frame}

\begin{frame}{Rappel : CBC}
  % wget https://upload.wikimedia.org/wikipedia/commons/8/80/CBC_encryption.svg
  % inkscape -D -z --file=CBC_encryption.svg --export-pdf=cbc-enc.pdf
  \includegraphics<1>[width=\textwidth]{cbc-enc}

  % wget https://upload.wikimedia.org/wikipedia/commons/2/2a/CBC_decryption.svg
  % inkscape -D -z --file=CBC_decryption.svg --export-pdf=cbc-dec.pdf
  \includegraphics<2>[width=\textwidth]{cbc-dec}

  \medskip

  (Crédit image : Wikipédia.)
\end{frame}

\begin{frame}{Chiffrement authentifié avec CBC}
  \begin{block}{TLS : MAC then Encrypt (MtE)}
    \begin{itemize}
      \item MAC = HMAC(métadonnées, message)
      \item Sortie = AES-CBC(message, MAC, padding)
    \end{itemize}
  \end{block}

  \begin{block}{Encrypt and MAC}
    \begin{itemize}
      \item MAC = HMAC(métadonnées, message)
      \item Sortie = AES-CBC(message, padding), MAC
    \end{itemize}
  \end{block}

  \begin{block}{Encrypt then MAC (EtM)}
    \begin{itemize}
      \item Chiffré = AES-CBC(message, padding)
      \item MAC = HMAC(métadonnées, chiffré)
      \item Sortie = Chiffré, MAC
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Détails sur le padding}
  \begin{block}{Principe}
    \begin{itemize}
      \item $L \in \{ 0, \dots, 255 \}$ tel que \( L + 1 + l(m) = 0 \mod b \).
      \item En pratique, \( L \in \{ 0, \dots, b - 1 \} \) et \( b = 16 \)
        pour AES.
      \item Valeur avec SSL 3.0 : $L$ octets quelconques suivis d'un octet de
        valeur $L$.
      \item Valeur avec TLS 1.x : $L + 1$ octets de valeur $L$.
    \end{itemize}
  \end{block}

  \begin{block}{Exemple}
    \begin{itemize}
      \item Message de longueur 4.
      \item Algos utilisés : AES et HMAC-SHA1.
      \item Longueur totale avant padding : 24 octets.
      \item Longueur typique du padding : 8 octets.
      \item Valeur du padding TLS : \texttt{07 07 07 07 07 07 07 07}.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Un oracle de padding : POODLE (1)}
  \begin{block}{Observation clé}
    \begin{itemize}
      \item Supposons qu'il y a un block complet de padding, chiffré $C_n$.
      \item On remplace $C_n$ par un $C'$ quelconque.
      \item Alors le message est accepté ssi $\text{AES}^{-1}(C') \oplus
        C_{n-1}$ se termine par un octet de valeur $15$. (Exercice.)
      \item Si le message est accepté (une fois sur 256) on connait le dernier
        octet de $\text{AES}^{-1}(C')$.
      \item La victime innocente s'est comportée comme un \emph{oracle}.
    \end{itemize}
  \end{block}

  \begin{block}{Contexte}
    \begin{itemize}
      \item On cherche à voler un cookie
      \item On peut générer des requêtes contenant le cookie
      \item On peut modifier la requête chiffrée sur le chemin
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[containsverbatim]{Un oracle de padding : POODLE (2)}
  \begin{Verbatim}[gobble=4]
    POST /path Cookie: name=?????\r\n\r\n body MAC padding
  \end{Verbatim}
  \begin{enumerate}
    \item On ajuste \texttt{path} et \texttt{body} pour que:
      \begin{itemize}
        \item L'octet visé soit le dernier du bloc $i$.
        \item Le padding soit de longueur un bloc exactement.
      \end{itemize}
    \item Le client innocent chiffre en $C_1, \dots, C_i, \dots, C_n$.
    \item On envoie au serveur $C_1, \dots, C_i, \dots, C_i$.
    \item Le serveur innocent nous donne une erreur, ou une fois sur 256, la
      valeur du dernier octet de $\text{AES}^{-1}(C_i)$.
    \item On XORe avec le dernier octet de $C_{i-1}$ pour trouver la valeur de
      l'octet visé.
    \item On passe à un autre octet jusqu'à avoir tout le cookie.
  \end{enumerate}
\end{frame}

\begin{frame}{Un oracle de padding : POODLE (3)}
  \begin{block}{Analyse}
    \begin{itemize}
      \item Le client innocent connait le cookie secret et la clé de
        chiffrement.
      \item Le serveur innocent connaît la clé de chiffrement.
      \item Le serveur nous donne 8 bits du secret avec probabilité $2^{-8}$.
    \end{itemize}
  \end{block}

  \begin{block}{Historique}
    \begin{itemize}
      \item 1999 : problème résolu dans TLS 1.0
      \item 2003 : principe de l'oracle connu
      \item 2015 : exploit pratique publié, accélère la mort de SSL 3.0
        (Padding Oracle On Downgraded Legacy Encryption)
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
